using Framework.GameMath;
using Framework.Logging;
using HermesProxy.Enums;
using HermesProxy.World.Enums;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace HermesProxy.World.Objects
{
    public struct SpeedInfo
    {
        public float WalkSpeed;
        public float RunSpeed;
        public float RunBackSpeed;
        public float SwimSpeed;
        public float SwimBackSpeed;
        public float FlightSpeed;
        public float FlightBackSpeed;
        public float TurnRate;
        public float PitchRate;

        public float GetCurrentSpeedFromMovementFlags(MovementFlagModern flags)
        {
            if (flags.HasAnyFlag(MovementFlagModern.MaskMovingXY))
            {
                if (flags.HasFlag(MovementFlagModern.Swimming))
                    return flags.HasFlag(MovementFlagModern.Backward) ? SwimBackSpeed : SwimSpeed;
                else if (flags.HasFlag(MovementFlagModern.Flying))
                    return flags.HasFlag(MovementFlagModern.Backward) ? FlightBackSpeed : FlightSpeed;
                else if (flags.HasFlag(MovementFlagModern.WalkMode))
                    return WalkSpeed;
                else
                    return flags.HasFlag(MovementFlagModern.Backward) ? RunBackSpeed : RunSpeed;
            }

            return 0.0f;
        }
    }

    public sealed class MovementInfo
    {
        public const float DEFAULT_WALK_SPEED = 2.5f;
        public const float DEFAULT_RUN_SPEED = 7.0f;
        public const float DEFAULT_RUN_BACK_SPEED = 4.5f;
        public const float DEFAULT_SWIM_SPEED = 4.72222f;
        public const float DEFAULT_SWIM_BACK_SPEED = 2.5f;
        public const float DEFAULT_FLY_SPEED = 7.0f;
        public const float DEFAULT_FLY_BACK_SPEED = 4.5f;
        public const float DEFAULT_TURN_RATE = 3.141593f;
        public const float DEFAULT_PITCH_RATE = 3.141593f;

        public uint Flags;
        public uint FlagsExtra;
        public uint FlagsExtra2;
        public uint MoveTime;
        public float SwimPitch;
        public uint FallTime;
        public float JumpHorizontalSpeed;
        public float JumpVerticalSpeed;
        public float JumpCosAngle;
        public float JumpSinAngle;
        public float SplineElevation;
        public bool HasSplineData;
        public Vector3 Position;
        public float Orientation;
        public float CorpseOrientation;
        public WowGuid128 TransportGuid;
        public Vector3 TransportOffset;
        public float TransportOrientation;
        public uint TransportTime;
        public uint TransportTime2;
        public sbyte TransportSeat = -1;
        public Quaternion Rotation;
        public SpeedInfo Speeds;
        public bool Hover;
        public float VehicleOrientation;
        public uint VehicleId; // Not exactly related to movement but it is read in ReadMovementUpdateBlock
        public uint TransportPathTimer; // only set for transports

        public MovementInfo CopyFromMe()
        {
            MovementInfo copy = new MovementInfo();
            copy.Flags = this.Flags;
            copy.FlagsExtra = this.FlagsExtra;
            copy.SwimPitch = this.SwimPitch;
            copy.FallTime = this.FallTime;
            copy.JumpHorizontalSpeed = this.JumpHorizontalSpeed;
            copy.JumpVerticalSpeed = this.JumpVerticalSpeed;
            copy.JumpCosAngle = this.JumpCosAngle;
            copy.JumpSinAngle = this.JumpSinAngle;
            copy.SplineElevation = this.SplineElevation;
            copy.HasSplineData = this.HasSplineData;
            copy.Position = this.Position;
            copy.Orientation = this.Orientation;
            copy.CorpseOrientation = this.CorpseOrientation;
            copy.TransportGuid = this.TransportGuid;
            copy.TransportOffset = this.TransportOffset;
            copy.TransportOrientation = this.TransportOrientation;
            copy.TransportTime = this.TransportTime;
            copy.TransportTime2 = this.TransportTime2;
            copy.TransportSeat = this.TransportSeat;
            copy.Rotation = this.Rotation;
            copy.Speeds = this.Speeds;
            copy.Hover = this.Hover;
            copy.VehicleId = this.VehicleId;
            copy.VehicleOrientation = this.VehicleOrientation;
            copy.TransportPathTimer = this.TransportPathTimer;
            return copy;
        }

        public void SetMovementFlags(MovementFlagModern f) { Flags = (uint)f; }
        public void AddMovementFlag(MovementFlagModern f) { Flags |= (uint)f; }
        public void RemoveMovementFlag(MovementFlagModern f) { Flags &= ~(uint)f; }
        public bool HasMovementFlag(MovementFlagModern f) { return (Flags & (uint)f) != 0; }

        public void ReadMovementInfoLegacy(WorldPacket packet, GameSessionData gameState)
        {
            MovementInfo info = this;

            bool hasPitch;
            if (LegacyVersion.AddedInVersion(ClientVersionBuild.V3_0_2_9056))
            {
                MovementFlagWotLK flags = (MovementFlagWotLK)packet.ReadUInt32();
                info.Flags = (uint)flags;
                info.FlagsExtra = packet.ReadUInt16();
                hasPitch = flags.HasAnyFlag(MovementFlagWotLK.Swimming | MovementFlagWotLK.Flying) || info.FlagsExtra.HasAnyFlag(MovementFlagExtra.AlwaysAllowPitching);
            }
            else if (LegacyVersion.AddedInVersion(ClientVersionBuild.V2_0_1_6180))
            {
                MovementFlagTBC flags = (MovementFlagTBC)packet.ReadUInt32();
                info.Flags = (uint)flags.CastFlags<MovementFlagWotLK>();
                info.FlagsExtra = packet.ReadUInt8();
                hasPitch = flags.HasAnyFlag(MovementFlagTBC.Swimming | MovementFlagTBC.Flying2);
            }
            else
            {
                MovementFlagVanilla flags = (MovementFlagVanilla)packet.ReadUInt32();
                info.Flags = (uint)flags.CastFlags<MovementFlagWotLK>();
                hasPitch = flags.HasAnyFlag(MovementFlagVanilla.Swimming);
                Hover = flags.HasAnyFlag(MovementFlagVanilla.FixedZ);
            }

            info.MoveTime = packet.ReadUInt32();

            info.Position = packet.ReadVector3();
            info.Orientation = packet.ReadFloat();

            if (info.Flags.HasAnyFlag(MovementFlagWotLK.OnTransport))
            {
                if (LegacyVersion.AddedInVersion(ClientVersionBuild.V3_1_0_9767))
                    info.TransportGuid = packet.ReadPackedGuid().To128(gameState);
                else
                    info.TransportGuid = packet.ReadGuid().To128(gameState);

                info.TransportOffset = packet.ReadVector3();
                info.TransportOrientation = packet.ReadFloat();

                if (LegacyVersion.AddedInVersion(ClientVersionBuild.V2_0_1_6180))
                    info.TransportTime = packet.ReadUInt32();

                if (LegacyVersion.AddedInVersion(ClientVersionBuild.V3_0_2_9056))
                    info.TransportSeat = packet.ReadInt8();

                if (info.FlagsExtra.HasAnyFlag(MovementFlagExtra.InterpolateMove))
                    info.TransportTime2 = packet.ReadUInt32();
            }

            if (hasPitch)
                info.SwimPitch = packet.ReadFloat();

            info.FallTime = packet.ReadUInt32();
            if (info.Flags.HasAnyFlag(MovementFlagWotLK.Falling))
            {
                info.JumpVerticalSpeed = packet.ReadFloat();
                info.JumpSinAngle = packet.ReadFloat();
                info.JumpCosAngle = packet.ReadFloat();
                info.JumpHorizontalSpeed = packet.ReadFloat();
            }

            if (info.Flags.HasAnyFlag(MovementFlagWotLK.SplineElevation))
                info.SplineElevation = packet.ReadFloat();
        }

        public void WriteMovementInfoLegacy(WorldPacket data)
        {
            MovementInfo info = this;

            uint flags;
            if (LegacyVersion.AddedInVersion(ClientVersionBuild.V3_0_2_9056))
                flags = (uint)(((MovementFlagModern)info.Flags).CastFlags<MovementFlagWotLK>());
            else if (LegacyVersion.AddedInVersion(ClientVersionBuild.V2_0_1_6180))
                flags = (uint)(((MovementFlagModern)info.Flags).CastFlags<MovementFlagTBC>());
            else
                flags = (uint)(((MovementFlagModern)info.Flags).CastFlags<MovementFlagVanilla>());

            if (info.TransportGuid != null)
            {
                if (LegacyVersion.AddedInVersion(ClientVersionBuild.V3_0_2_9056))
                    flags |= (uint)MovementFlagWotLK.OnTransport;
                else if (LegacyVersion.AddedInVersion(ClientVersionBuild.V2_0_1_6180))
                    flags |= (uint)MovementFlagTBC.OnTransport;
                else
                    flags |= (uint)MovementFlagVanilla.OnTransport;
            }
            
            data.WriteUInt32(flags);

            if (LegacyVersion.AddedInVersion(ClientVersionBuild.V3_0_2_9056))
                data.WriteUInt16((ushort)info.FlagsExtra);
            else if (LegacyVersion.AddedInVersion(ClientVersionBuild.V2_0_1_6180))
                data.WriteUInt8((byte)info.FlagsExtra);

            data.WriteUInt32(info.MoveTime);
            data.WriteVector3(info.Position);
            data.WriteFloat(info.Orientation);

            bool hasTransport;
            if (LegacyVersion.AddedInVersion(ClientVersionBuild.V3_0_2_9056))
                hasTransport = flags.HasAnyFlag(MovementFlagWotLK.OnTransport);
            else if (LegacyVersion.AddedInVersion(ClientVersionBuild.V2_0_1_6180))
                hasTransport = flags.HasAnyFlag(MovementFlagTBC.OnTransport);
            else
                hasTransport = flags.HasAnyFlag(MovementFlagVanilla.OnTransport);

            if (hasTransport)
            {
                if (LegacyVersion.AddedInVersion(ClientVersionBuild.V3_1_0_9767))
                    data.WritePackedGuid(info.TransportGuid.To64());
                else
                    data.WriteGuid(info.TransportGuid.To64());

                data.WriteVector3(info.TransportOffset);
                data.WriteFloat(info.TransportOrientation);

                if (LegacyVersion.AddedInVersion(ClientVersionBuild.V2_0_1_6180))
                    data.WriteUInt32(info.TransportTime);

                if (LegacyVersion.AddedInVersion(ClientVersionBuild.V3_0_2_9056))
                    data.WriteInt8(info.TransportSeat);

                if (LegacyVersion.AddedInVersion(ClientVersionBuild.V3_0_2_9056) &&
                    info.FlagsExtra.HasAnyFlag(MovementFlagExtra.InterpolateMove))
                    data.WriteUInt32(info.TransportTime2);
            }

            bool hasSwimPitch;
            if (LegacyVersion.AddedInVersion(ClientVersionBuild.V3_0_2_9056))
                hasSwimPitch = flags.HasAnyFlag(MovementFlagWotLK.Swimming | MovementFlagWotLK.Flying) || info.FlagsExtra.HasAnyFlag(MovementFlagExtra.AlwaysAllowPitching);
            else if (LegacyVersion.AddedInVersion(ClientVersionBuild.V2_0_1_6180))
                hasSwimPitch = flags.HasAnyFlag(MovementFlagTBC.Swimming | MovementFlagTBC.Flying2);
            else
                hasSwimPitch = flags.HasAnyFlag(MovementFlagVanilla.Swimming);

            if (hasSwimPitch)
                data.WriteFloat(info.SwimPitch);

            data.WriteUInt32(info.FallTime);

            bool hasFallDirection;
            if (LegacyVersion.AddedInVersion(ClientVersionBuild.V3_0_2_9056))
                hasFallDirection = flags.HasAnyFlag(MovementFlagWotLK.Falling);
            else if (LegacyVersion.AddedInVersion(ClientVersionBuild.V2_0_1_6180))
                hasFallDirection = flags.HasAnyFlag(MovementFlagTBC.Falling);
            else
                hasFallDirection = flags.HasAnyFlag(MovementFlagVanilla.Falling);

            if (hasFallDirection)
            {
                data.WriteFloat(info.JumpVerticalSpeed);
                data.WriteFloat(info.JumpSinAngle);
                data.WriteFloat(info.JumpCosAngle);
                data.WriteFloat(info.JumpHorizontalSpeed);
            }

            bool hasSplineElevation;
            if (LegacyVersion.AddedInVersion(ClientVersionBuild.V3_0_2_9056))
                hasSplineElevation = flags.HasAnyFlag(MovementFlagWotLK.SplineElevation);
            else if (LegacyVersion.AddedInVersion(ClientVersionBuild.V2_0_1_6180))
                hasSplineElevation = flags.HasAnyFlag(MovementFlagTBC.SplineElevation);
            else
                hasSplineElevation = flags.HasAnyFlag(MovementFlagVanilla.SplineElevation);

            if (hasSplineElevation)
                data.WriteFloat(info.SplineElevation);
        }

        public void ReadMovementInfoModern(WorldPacket data)
        {
            var moveInfo = this;

            if (ModernVersion.AddedInVersion(9, 2, 0, 1, 14, 1, 2, 5, 3))
            {
                moveInfo.Flags = data.ReadUInt32();
                moveInfo.FlagsExtra = data.ReadUInt32();
                moveInfo.FlagsExtra2 = data.ReadUInt32();
            }

            moveInfo.MoveTime = data.ReadUInt32();
            moveInfo.Position = data.ReadVector3();
            moveInfo.Orientation = data.ReadFloat();

            moveInfo.SwimPitch = data.ReadFloat();
            moveInfo.SplineElevation = data.ReadFloat();

            uint removeMovementForcesCount = data.ReadUInt32();

            uint moveIndex = data.ReadUInt32();

            for (uint i = 0; i < removeMovementForcesCount; ++i)
            {
                data.ReadPackedGuid128();
            }

            // ResetBitReader

            if (!ModernVersion.AddedInVersion(9, 2, 0, 1, 14, 1, 2, 5, 3))
            {
                moveInfo.Flags = data.ReadBits<uint>(30);
                moveInfo.FlagsExtra = data.ReadBits<uint>(18);
            }

            bool hasTransport = data.HasBit();
            bool hasFall = data.HasBit();
            bool hasSpline = data.HasBit(); // todo 6.x read this infos

            data.ReadBit(); // HeightChangeFailed
            data.ReadBit(); // RemoteTimeValid
            bool hasInertia = ModernVersion.AddedInVersion(9, 2, 0, 1, 14, 1, 2, 5, 3) ? data.HasBit() : false;

            if (hasTransport)
                ReadTransportInfoModern(data);

            if (ModernVersion.AddedInVersion(9, 2, 0, 1, 14, 1, 2, 5, 3))
            {
                if (hasInertia)
                {
                    data.ReadPackedGuid128();
                    data.ReadVector3(); // Force
                    data.ReadUInt32(); // Lifetime
                }
            }

            if (hasFall)
            {
                moveInfo.FallTime = data.ReadUInt32();
                moveInfo.JumpVerticalSpeed = data.ReadFloat();

                // ResetBitReader

                bool hasFallDirection = data.HasBit();
                if (hasFallDirection)
                {
                    moveInfo.JumpSinAngle = data.ReadFloat();
                    moveInfo.JumpCosAngle = data.ReadFloat();
                    moveInfo.JumpHorizontalSpeed = data.ReadFloat();
                }
            }
        }

        public void ReadTransportInfoModern(WorldPacket data)
        {
            var moveInfo = this;
            moveInfo.TransportGuid = data.ReadPackedGuid128();
            moveInfo.TransportOffset = data.ReadVector3();
            moveInfo.TransportOrientation = data.ReadFloat();
            moveInfo.TransportSeat = data.ReadInt8();           // VehicleSeatIndex
            moveInfo.TransportTime = data.ReadUInt32();         // MoveTime

            bool hasPrevTime = data.HasBit();
            bool hasVehicleId = data.HasBit();

            if (hasPrevTime)
                moveInfo.TransportTime2 = data.ReadUInt32();    // PrevMoveTime

            if (hasVehicleId)
                moveInfo.VehicleId = data.ReadUInt32();         // VehicleRecID
        }

        public void WriteMovementInfoModern(WorldPacket data, WowGuid128 guid)
        {
            MovementInfo moveInfo = this;
            bool hasFallDirection = moveInfo.Flags.HasAnyFlag(MovementFlagModern.Falling | MovementFlagModern.FallingFar);
            bool hasFall = hasFallDirection || moveInfo.FallTime != 0;

            data.WritePackedGuid128(guid);                                  // MoverGUID

            if (ModernVersion.AddedInVersion(9, 2, 0, 1, 14, 1, 2, 5, 3))
            {
                data.WriteUInt32(Flags);
                data.WriteUInt32(FlagsExtra);
                data.WriteUInt32(FlagsExtra2);
            }

            data.WriteUInt32(moveInfo.MoveTime);                            // MoveTime
            data.WriteFloat(moveInfo.Position.X);
            data.WriteFloat(moveInfo.Position.Y);
            data.WriteFloat(moveInfo.Position.Z);
            data.WriteFloat(moveInfo.Orientation);

            data.WriteFloat(moveInfo.SwimPitch);                            // Pitch
            data.WriteFloat(moveInfo.SplineElevation);                      // StepUpStartElevation

            data.WriteUInt32(0);                                            // RemoveForcesIDs.size()
            data.WriteUInt32(0);                                            // MoveIndex

            //for (public uint i = 0; i < RemoveForcesIDs.Count; ++i)
            //    *data << ObjectGuid(RemoveForcesIDs);

            if (!ModernVersion.AddedInVersion(9, 2, 0, 1, 14, 1, 2, 5, 3))
            {
                data.WriteBits(moveInfo.Flags, 30);
                data.WriteBits(moveInfo.FlagsExtra, 18);
            }
                
            data.WriteBit(moveInfo.TransportGuid != null);                 // HasTransport
            data.WriteBit(hasFall);                                        // HasFall
            data.WriteBit(HasSplineData);                                  // HasSpline - marks that the unit uses spline movement
            data.WriteBit(false);                                          // HeightChangeFailed
            data.WriteBit(false);                                          // RemoteTimeValid
            if (ModernVersion.AddedInVersion(9, 2, 0, 1, 14, 1, 2, 5, 3))
                data.WriteBit(false);                                      // HasInertia
            data.FlushBits();

            if (moveInfo.TransportGuid != null)
                WriteTransportInfoModern(data);

            /*
            if (ModernVersion.AddedInVersion(9, 2, 0, 1, 14, 1, 2, 5, 3))
            {
                if (Inertia != null)
                {
                    data.WritePackedGuid128(Inertia.Guid);
                    data.WriteVector3(Inertia.Force);
                    data.WriteUInt32(Inertia.Lifetime);
                }
            }
            */

            if (hasFall)
            {
                data.WriteUInt32(moveInfo.FallTime);                              // Time
                data.WriteFloat(moveInfo.JumpVerticalSpeed);                      // JumpVelocity
                data.WriteBit(hasFallDirection);
                data.FlushBits();

                if (hasFallDirection)
                {
                    data.WriteFloat(moveInfo.JumpSinAngle);                       // Direction
                    data.WriteFloat(moveInfo.JumpCosAngle);
                    data.WriteFloat(moveInfo.JumpHorizontalSpeed);                // Speed
                }
            }
        }
        public void WriteTransportInfoModern(WorldPacket data)
        {
            MovementInfo moveInfo = this;
            bool hasPrevTime = false;
            bool hasVehicleId = moveInfo.VehicleId != 0;

            data.WritePackedGuid128(moveInfo.TransportGuid);
            data.WriteFloat(moveInfo.TransportOffset.X);
            data.WriteFloat(moveInfo.TransportOffset.Y);
            data.WriteFloat(moveInfo.TransportOffset.Z);
            data.WriteFloat(moveInfo.TransportOrientation);
            data.WriteInt8(moveInfo.TransportSeat);
            data.WriteUInt32(moveInfo.TransportTime);

            data.WriteBit(hasPrevTime);
            data.WriteBit(hasVehicleId);
            data.FlushBits();

            if (hasPrevTime)
                data.WriteUInt32(0); // PrevMoveTime

            if (hasVehicleId)
                data.WriteUInt32(moveInfo.VehicleId);
        }

        public static void ClampOrientation(ref float orientation)
        {
            while (orientation < 0)
                orientation += (float)(Math.PI * 2f);
            while (orientation > (float)(Math.PI * 2f))
                orientation -= (float)(Math.PI * 2f);
        }

        // Must be called only after movement flags are converted to modern enum!
        public void ValidateMovementInfo()
        {
            ClampOrientation(ref Orientation);
            ClampOrientation(ref TransportOrientation);

            var RemoveViolatingFlags = new Action<bool, MovementFlagModern>((check, maskToRemove) =>
            {
                if (check)
                {
                    Log.Print(LogType.Error, $"Violation of MovementFlags found ({check}). MovementFlags: {Flags}, MovementFlags2: {FlagsExtra}. Mask {maskToRemove} will be removed.");
                    RemoveMovementFlag(maskToRemove);
                }
            });

            /*! This must be a packet spoofing attempt. MOVEMENTFLAG_ROOT sent from the client is not valid
                in conjunction with any of the moving movement flags such as MOVEMENTFLAG_FORWARD.
                It will freeze clients that receive this player's movement info.
            */
            RemoveViolatingFlags(HasMovementFlag(MovementFlagModern.Root) && HasMovementFlag(MovementFlagModern.MaskMoving), MovementFlagModern.MaskMoving);

            //! Cannot ascend and descend at the same time
            RemoveViolatingFlags(HasMovementFlag(MovementFlagModern.Ascending) && HasMovementFlag(MovementFlagModern.Descending),
                MovementFlagModern.Ascending | MovementFlagModern.Descending);

            //! Cannot move left and right at the same time
            RemoveViolatingFlags(HasMovementFlag(MovementFlagModern.TurnLeft) && HasMovementFlag(MovementFlagModern.TurnRight),
                MovementFlagModern.TurnLeft | MovementFlagModern.TurnRight);

            //! Cannot strafe left and right at the same time
            RemoveViolatingFlags(HasMovementFlag(MovementFlagModern.StrafeLeft) && HasMovementFlag(MovementFlagModern.StrafeRight),
                MovementFlagModern.StrafeLeft | MovementFlagModern.StrafeRight);

            //! Cannot pitch up and down at the same time
            RemoveViolatingFlags(HasMovementFlag(MovementFlagModern.PitchUp) && HasMovementFlag(MovementFlagModern.PitchDown),
                MovementFlagModern.PitchUp | MovementFlagModern.PitchDown);

            //! Cannot move forwards and backwards at the same time
            RemoveViolatingFlags(HasMovementFlag(MovementFlagModern.Forward) && HasMovementFlag(MovementFlagModern.Backward),
                MovementFlagModern.Forward | MovementFlagModern.Backward);

            RemoveViolatingFlags(HasMovementFlag(MovementFlagModern.DisableGravity | MovementFlagModern.CanFly) && HasMovementFlag(MovementFlagModern.Falling),
                MovementFlagModern.Falling);

            RemoveViolatingFlags(HasMovementFlag(MovementFlagModern.SplineElevation) && MathFunctions.fuzzyEq(SplineElevation, 0.0f), MovementFlagModern.SplineElevation);

            // Client first checks if spline elevation != 0, then verifies flag presence
            if (MathFunctions.fuzzyNe(SplineElevation, 0.0f))
                AddMovementFlag(MovementFlagModern.SplineElevation);
        }
    }
}
